PyART.numerical.twopuncts_ID
============================

.. py:module:: PyART.numerical.twopuncts_ID


Attributes
----------

.. autoapisummary::

   PyART.numerical.twopuncts_ID.file_path
   PyART.numerical.twopuncts_ID.file_dir
   PyART.numerical.twopuncts_ID.DUMMY
   PyART.numerical.twopuncts_ID.parser


Classes
-------

.. autoapisummary::

   PyART.numerical.twopuncts_ID.LinearScaler
   PyART.numerical.twopuncts_ID.TwoPunctID


Module Contents
---------------

.. py:data:: file_path
   :value: b'.'


.. py:data:: file_dir

.. py:data:: DUMMY

.. py:class:: LinearScaler(A, B, C, D)

   Class to perform linear transformation and its inverse
   between two intervals [A,B] and [C,D]


   .. py:attribute:: A


   .. py:attribute:: B


   .. py:attribute:: C


   .. py:attribute:: D


   .. py:method:: transform(x)

      Transform x from interval [A,B] to [C,D].

      :param x: Value(s) in the original interval [A,B] to be transformed.
      :type x: float or array-like

      :returns: Transformed value(s) in the target interval [C,D].
      :rtype: float or array-like



   .. py:method:: inverse_transform(y)

      Inverse transform y from interval [C,D] to [A,B].

      :param y: Value(s) in the target interval [C,D] to be inverse transformed.
      :type y: float or array-like

      :returns: Inverse transformed value(s) in the original interval [A,B].
      :rtype: float or array-like



   .. py:method:: __lin_transf(A, B, C, D, x)

      Apply linear transformation from [A,B] to [C,D].

      :param A: Lower bound of the original interval.
      :type A: float
      :param B: Upper bound of the original interval.
      :type B: float
      :param C: Lower bound of the target interval.
      :type C: float
      :param D: Upper bound of the target interval.
      :type D: float
      :param x: Value(s) to be transformed.
      :type x: float or array-like

      :returns: Transformed value(s).
      :rtype: float or array-like



.. py:class:: TwoPunctID(**kwargs)

   Bases: :py:obj:`object`


   Class to setup initial data computation
   using the TwoPunctures code.
   See: https://github.com/computationalrelativity/TwoPuncturesC


   .. py:attribute:: M
      :value: 1.0



   .. py:attribute:: q
      :value: 1.0



   .. py:attribute:: E
      :value: 1.1



   .. py:attribute:: E_min
      :value: None



   .. py:attribute:: L
      :value: 1.0



   .. py:attribute:: D
      :value: 100



   .. py:attribute:: chi1z
      :value: 0.0



   .. py:attribute:: chi2z
      :value: 0.0



   .. py:attribute:: npoints_A
      :value: 8



   .. py:attribute:: npoints_B
      :value: 8



   .. py:attribute:: npoints_phi
      :value: 6



   .. py:attribute:: TP_dummy


   .. py:attribute:: TP_exe
      :value: './TwoPunctures.x'



   .. py:attribute:: outdir
      :value: './'



   .. py:attribute:: verbose
      :value: False



   .. py:attribute:: iteration
      :value: None



   .. py:attribute:: TP_pars


   .. py:attribute:: TP_int_vars
      :value: ['npoints_A', 'npoints_B', 'npoints_phi', 'give_bare_mass']



   .. py:method:: create_TP_parfile(P, parfile=None, outdir=None)

      Create a parameter file for TwoPunctures with given momentum P.
      Assumes L along z axis and initial separation along x axis.

      :param P: Magnitude of the linear momentum for each puncture.
      :type P: float
      :param parfile: Name of the parameter file to create (default is None, which uses "parfile_P{P:.10f}.par").
      :type parfile: str or None, optional
      :param outdir: Output directory to save the parameter file (default is None, which uses self.outdir).
      :type outdir: str or None, optional

      :returns: Path to the created parameter file.
      :rtype: str



   .. py:method:: run_TP_from_parfile(parfile)

      Run TwoPunctures with the given parameter file.
      :param parfile: Path to the parameter file to use.
      :type parfile: str

      :returns: Path to the output file generated by TwoPunctures.
      :rtype: str



   .. py:method:: read_TP_output(outfile)

      Read the output file from TwoPunctures and extract E_ADM, M1, and M2.

      :param outfile: Path to the output file generated by TwoPunctures.
      :type outfile: str

      :returns: * **E_ADM** (*float*) -- Total ADM energy.
                * **M1** (*float*) -- ADM mass of puncture 1.
                * **M2** (*float*) -- ADM mass of puncture 2.



   .. py:method:: run_TP_wrapper(P, parfile=None, verbose=None)

      Run the full TwoPunctures workflow: create parfile, run TP, read output.
      :param P: Magnitude of the linear momentum for each puncture.
      :type P: float
      :param parfile: Name of the parameter file to create (default is None, which uses "parfile_P{P:.10f}.par").
      :type parfile: str or None, optional
      :param verbose: If True, print verbose output (default is None, which uses self.verbose).
      :type verbose: bool or None, optional

      :returns: * **E_ADM** (*float*) -- Total ADM energy.
                * **M1** (*float*) -- ADM mass of puncture 1.
                * **M2** (*float*) -- ADM mass of puncture 2.



   .. py:method:: run_TP_parallel(momenta, batch)

      Run TwoPunctures in parallel for a batch of momenta.
      :param momenta: Array of momenta to evaluate.
      :type momenta: array-like
      :param batch: List of indices in the momenta array to process in this batch.
      :type batch: list of int

      :returns: **energies** -- Array of computed ADM energies for the given momenta.
      :rtype: array-like



   .. py:method:: fit_iter(P0, dP, npoints=4, poly_order=None, verbose=None, show_plot=False, save_plot=False, x0_position='centered', nproc=1)

      Fit a polynomial to find the momentum P that gives the desired energy self.E.

      :param P0: Initial guess for the momentum.
      :type P0: float
      :param dP: Step size for the momentum.
      :type dP: float
      :param npoints: Number of points to evaluate in each iteration (default is 4).
      :type npoints: int, optional
      :param poly_order: Order of the polynomial fit (default is None, which uses min(max(npoints-1,1),5)).
      :type poly_order: int or None, optional
      :param verbose: If True, print verbose output (default is None, which uses self.verbose).
      :type verbose: bool or None, optional
      :param show_plot: If True, show the fit plot (default is False).
      :type show_plot: bool, optional
      :param save_plot: If True, save the fit plot (default is False).
      :type save_plot: bool, optional
      :param x0_position: Positioning of the points relative to P0: "centered", "highest", or "lowest" (default is "centered").
      :type x0_position: str, optional
      :param nproc: Number of processors to use for parallel execution (default is 1).
      :type nproc: int, optional

      :returns: **Pf** -- Fitted momentum that gives the desired energy self.E.
      :rtype: float



   .. py:method:: fit_iterations(P0=None, step_rel=0.15, tol=1e-10, resize_factor=100, itermax=5, npoints=4, poly_order=None, verbose=None, nproc=1, save_plot=False, show_plot=False)

      Iteratively fit to find the momentum P that gives the desired energy self.E.
      :param P0: Initial guess for the momentum (default is None, which uses an estimate based on self.E
                 and self.q).
      :type P0: float or None, optional
      :param step_rel: Initial relative step size for the momentum (default is 0.15).
      :type step_rel: float, optional
      :param tol: Tolerance for the relative error in energy (default is 1e-10).
      :type tol: float, optional
      :param resize_factor: Factor to resize the step size in each iteration (default is 100).
      :type resize_factor: float, optional
      :param itermax: Maximum number of iterations (default is 5).
      :type itermax: int, optional
      :param npoints: Number of points to evaluate in each iteration (default is 4).
      :type npoints: int, optional
      :param poly_order: Order of the polynomial fit (default is None, which uses min(max(npoints-1,1),5)).
      :type poly_order: int or None, optional
      :param verbose: If True, print verbose output (default is None, which uses self.verbose).
      :type verbose: bool or None, optional
      :param nproc: Number of processors to use for parallel execution (default is 1).
      :type nproc: int, optional
      :param save_plot: If True, save the fit plots for each iteration (default is False).
      :type save_plot: bool, optional
      :param show_plot: If True, show the fit plots for each iteration (default is False).
      :type show_plot: bool, optional



.. py:data:: parser

